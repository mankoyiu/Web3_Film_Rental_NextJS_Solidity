"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/contexts/Web3Context.tsx":
/*!**************************************!*\
  !*** ./src/contexts/Web3Context.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Web3Provider: () => (/* binding */ Web3Provider),\n/* harmony export */   useWeb3: () => (/* binding */ useWeb3)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useAccount.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useConnect.js\");\n/* harmony import */ var wagmi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! wagmi */ \"(app-pages-browser)/./node_modules/wagmi/dist/esm/hooks/useDisconnect.js\");\n/* harmony import */ var wagmi_connectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! wagmi/connectors */ \"(app-pages-browser)/./node_modules/@wagmi/core/dist/esm/connectors/injected.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/providers/provider-browser.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/contract/contract.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var _services_rentalStorage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/rentalStorage */ \"(app-pages-browser)/./src/services/rentalStorage.ts\");\n/* __next_internal_client_entry_do_not_use__ Web3Provider,useWeb3 auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n// Import ABI when available\nconst FILM_RENTAL_ABI = [\n    \"function addFilm(string memory _id, uint256 _rentalPrice) public\",\n    \"function rentFilm(string memory _filmId) public payable\",\n    \"function endRental(string memory _filmId) public\",\n    \"function getRentalPrice(string memory _filmId) public view returns (uint256)\",\n    \"function isFilmAvailable(string memory _filmId) public view returns (bool)\",\n    \"function getUserRentals(address _user) public view returns (tuple(string filmId, address renter, uint256 startTime, uint256 endTime, bool isActive)[] memory)\"\n];\n// Updated with the deployed contract address\nconst CONTRACT_ADDRESS = \"0x8D1517360886e85d8e94E3E64742A7637277c5f2\";\nconst Web3Context = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Local storage key for wallet connection state\nconst WALLET_CONNECTED_KEY = 'wallet_connected';\nfunction Web3Provider(param) {\n    let { children } = param;\n    _s();\n    const { address, isConnected } = (0,wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount)();\n    const { connectAsync } = (0,wagmi__WEBPACK_IMPORTED_MODULE_4__.useConnect)();\n    const { disconnect: wagmiDisconnect } = (0,wagmi__WEBPACK_IMPORTED_MODULE_5__.useDisconnect)();\n    const [contract, setContract] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [initialLoadComplete, setInitialLoadComplete] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Check localStorage on initial load\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Web3Provider.useEffect\": ()=>{\n            const checkStoredConnection = {\n                \"Web3Provider.useEffect.checkStoredConnection\": async ()=>{\n                    if (true) {\n                        const storedConnected = localStorage.getItem(WALLET_CONNECTED_KEY) === 'true';\n                        if (storedConnected && !isConnected) {\n                            try {\n                                // Try to reconnect wallet if it was previously connected\n                                await connectAsync({\n                                    connector: (0,wagmi_connectors__WEBPACK_IMPORTED_MODULE_6__.injected)()\n                                });\n                            } catch (err) {\n                                console.error('Failed to restore wallet connection:', err);\n                                localStorage.removeItem(WALLET_CONNECTED_KEY);\n                            }\n                        }\n                        setInitialLoadComplete(true);\n                    }\n                }\n            }[\"Web3Provider.useEffect.checkStoredConnection\"];\n            checkStoredConnection();\n        }\n    }[\"Web3Provider.useEffect\"], []);\n    // Update contract when connection changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Web3Provider.useEffect\": ()=>{\n            if (isConnected && address) {\n                // Save connection state to localStorage\n                if ( true && initialLoadComplete) {\n                    localStorage.setItem(WALLET_CONNECTED_KEY, 'true');\n                }\n                initializeContract();\n            } else {\n                setContract(null);\n                // Clear connection state from localStorage\n                if ( true && initialLoadComplete) {\n                    localStorage.removeItem(WALLET_CONNECTED_KEY);\n                }\n            }\n        }\n    }[\"Web3Provider.useEffect\"], [\n        isConnected,\n        address,\n        initialLoadComplete\n    ]);\n    const initializeContract = async ()=>{\n        try {\n            if ( false || !window.ethereum || !address) return;\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.BrowserProvider(window.ethereum);\n            const signer = await provider.getSigner();\n            const contractInstance = new ethers__WEBPACK_IMPORTED_MODULE_8__.Contract(CONTRACT_ADDRESS, FILM_RENTAL_ABI, signer);\n            setContract(contractInstance);\n        } catch (err) {\n            setError('Failed to initialize contract: ' + ((err === null || err === void 0 ? void 0 : err.message) || err));\n        }\n    };\n    const connect = async ()=>{\n        setError(null);\n        try {\n            await connectAsync({\n                connector: (0,wagmi_connectors__WEBPACK_IMPORTED_MODULE_6__.injected)()\n            });\n        // Connection state is saved in the useEffect that watches isConnected\n        } catch (err) {\n            setError('Wallet connection failed: ' + ((err === null || err === void 0 ? void 0 : err.message) || err));\n        }\n    };\n    const disconnect = ()=>{\n        wagmiDisconnect();\n    // Connection state is cleared in the useEffect that watches isConnected\n    };\n    const rentFilm = async (filmId, price, filmTitle, filmPoster)=>{\n        if (!window.ethereum) throw new Error('No crypto wallet found. Please install MetaMask.');\n        if (!isConnected || !address) throw new Error('Wallet not connected');\n        try {\n            // Check if film is already rented by this user\n            if (true) {\n                const storedRentalsKey = \"rentals_\".concat(address.toLowerCase());\n                const storedRentals = localStorage.getItem(storedRentalsKey);\n                if (storedRentals) {\n                    const userRentals = JSON.parse(storedRentals);\n                    const now = new Date();\n                    // Check if this film is already in active rentals\n                    const isAlreadyRented = userRentals.some((rental)=>{\n                        return rental.filmId === filmId && new Date(rental.expiresAt) > now;\n                    });\n                    if (isAlreadyRented) {\n                        throw new Error('You have already rented this film. Check your rentals page to watch it.');\n                    }\n                }\n            }\n            const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.BrowserProvider(window.ethereum);\n            const signer = await provider.getSigner();\n            const userAddress = await signer.getAddress();\n            //ETH address that receive ETH from users\n            const adminAddress = '0xeC1f782d67575FE1E62078986b05a053bdD46602';\n            let ethBalance = await provider.getBalance(userAddress);\n            const priceWei = ethers__WEBPACK_IMPORTED_MODULE_9__.parseEther(price);\n            // Debug: log types and values\n            console.log('DEBUG ethBalance:', ethBalance, typeof ethBalance);\n            console.log('DEBUG priceWei:', priceWei, typeof priceWei);\n            // Ensure both are BigInt for comparison\n            if (typeof ethBalance !== 'bigint') {\n                ethBalance = BigInt(ethBalance.toString());\n            }\n            if (typeof priceWei !== 'bigint') {\n                throw new Error('priceWei is not a bigint');\n            }\n            if (ethBalance < priceWei) {\n                throw new Error('Insufficient balance to rent this film.');\n            }\n            console.log('Renting film:', {\n                filmId,\n                price,\n                filmTitle\n            });\n            // Send ETH to admin\n            const tx = await signer.sendTransaction({\n                to: adminAddress,\n                value: priceWei\n            });\n            await tx.wait();\n            // Store rental information in localStorage\n            const now = Date.now();\n            const sevenDaysInMs = 7 * 24 * 60 * 60 * 1000;\n            const expiresAt = now + sevenDaysInMs;\n            const newRental = {\n                id: \"\".concat(filmId, \"-\").concat(now),\n                filmId: filmId,\n                title: filmTitle || \"Film \".concat(filmId),\n                poster: filmPoster || 'https://via.placeholder.com/300x450?text=Film',\n                rentedAt: new Date(now).toISOString(),\n                expiresAt: new Date(expiresAt).toISOString(),\n                status: 'active',\n                price: price\n            };\n            // Get existing rentals and add the new one\n            let userRentals = await (0,_services_rentalStorage__WEBPACK_IMPORTED_MODULE_2__.loadRentals)(userAddress);\n            userRentals.push(newRental);\n            // Save to both localStorage and server file storage\n            await (0,_services_rentalStorage__WEBPACK_IMPORTED_MODULE_2__.saveRentals)(userAddress, userRentals);\n            console.log('Rental saved to storage:', newRental);\n            // Update film rental count and revenue in films.json\n            try {\n                // Fetch current films data\n                const filmsResponse = await fetch('/api/films');\n                if (filmsResponse.ok) {\n                    const films = await filmsResponse.json();\n                    // Find the film that was rented\n                    const filmIndex = films.findIndex((film)=>film.id === filmId);\n                    if (filmIndex !== -1) {\n                        // Increment rental count\n                        films[filmIndex].rentals = (films[filmIndex].rentals || 0) + 1;\n                        // Add revenue (convert price string to number)\n                        films[filmIndex].revenue = (films[filmIndex].revenue || 0) + parseFloat(price);\n                        console.log(\"Updated film \".concat(filmId, \" rentals to \").concat(films[filmIndex].rentals, \" and revenue to \").concat(films[filmIndex].revenue));\n                        // Save updated films data back to the server\n                        await fetch('/api/films', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify(films)\n                        });\n                        console.log('Films data updated successfully');\n                    }\n                }\n            } catch (updateError) {\n                console.error('Error updating film rental statistics:', updateError);\n            // Continue execution even if statistics update fails\n            }\n            return tx;\n        } catch (err) {\n            var _err_message;\n            console.error('Failed to rent film:', err);\n            // Handle MetaMask user rejection\n            if ((err === null || err === void 0 ? void 0 : err.code) === 4001 || (err === null || err === void 0 ? void 0 : err.reason) === 'rejected' || (err === null || err === void 0 ? void 0 : (_err_message = err.message) === null || _err_message === void 0 ? void 0 : _err_message.includes('User denied transaction signature')) || (err === null || err === void 0 ? void 0 : err.code) === 'ACTION_REJECTED') {\n                throw new Error('Transaction cancelled by user.');\n            }\n            throw new Error((err === null || err === void 0 ? void 0 : err.message) || 'Failed to rent film.');\n        }\n    };\n    const endRental = async (filmId)=>{\n        // Web3 functionality temporarily disabled while we focus on traditional auth\n        console.log('Web3 functionality temporarily disabled');\n        throw new Error('Web3 functionality temporarily disabled');\n    /*\n    if (!contract) throw new Error('Contract not initialized')\n    try {\n      const tx = await contract.endRental(filmId)\n      await tx.wait()\n    } catch (error) {\n      console.error('Failed to end rental:', error)\n      throw error\n    }\n    */ };\n    const getFilmPrice = async (filmId)=>{\n        // Web3 functionality temporarily disabled while we focus on traditional auth\n        console.log('Web3 functionality temporarily disabled');\n        return '0.01' // Return a default price\n        ;\n    /*\n    if (!contract) throw new Error('Contract not initialized')\n    try {\n      const price = await contract.getRentalPrice(filmId)\n      const ethPrice = ethers.formatEther(price.toString())\n      return ethPrice\n    } catch (error) {\n      console.error('Failed to get film price:', error)\n      throw error\n    }\n    */ };\n    const isFilmAvailable = async (filmId)=>{\n        // Web3 functionality temporarily disabled while we focus on traditional auth\n        console.log('Web3 functionality temporarily disabled');\n        return true // Default to available\n        ;\n    /*\n    if (!contract) throw new Error('Contract not initialized')\n    try {\n      return await contract.isFilmAvailable(filmId)\n    } catch (error) {\n      console.error('Failed to check film availability:', error)\n      throw error\n    }\n    */ };\n    const getUserRentals = async ()=>{\n        if (!window.ethereum) throw new Error('No crypto wallet found. Please install MetaMask.');\n        if (!isConnected || !address) throw new Error('Wallet not connected');\n        try {\n            console.log('Fetching rentals for address:', address);\n            // Load rentals from both localStorage and server file storage\n            const userRentals = await (0,_services_rentalStorage__WEBPACK_IMPORTED_MODULE_2__.loadRentals)(address);\n            console.log('Retrieved rentals from storage:', userRentals);\n            return userRentals;\n        } catch (error) {\n            console.error('Failed to get user rentals:', error);\n            throw error;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Web3Context.Provider, {\n        value: {\n            isConnected,\n            account: address,\n            connect,\n            disconnect,\n            rentFilm,\n            endRental,\n            getFilmPrice,\n            isFilmAvailable,\n            getUserRentals,\n            contract\n        },\n        children: [\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    color: 'red',\n                    marginBottom: 8\n                },\n                children: [\n                    \"Wallet Error: \",\n                    error\n                ]\n            }, void 0, true, {\n                fileName: \"/Volumes/ssd/project/src/contexts/Web3Context.tsx\",\n                lineNumber: 322,\n                columnNumber: 17\n            }, this),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"/Volumes/ssd/project/src/contexts/Web3Context.tsx\",\n        lineNumber: 310,\n        columnNumber: 5\n    }, this);\n}\n_s(Web3Provider, \"5RX3IK99AMz7Wy7ih2z7+VKCA5I=\", false, function() {\n    return [\n        wagmi__WEBPACK_IMPORTED_MODULE_3__.useAccount,\n        wagmi__WEBPACK_IMPORTED_MODULE_4__.useConnect,\n        wagmi__WEBPACK_IMPORTED_MODULE_5__.useDisconnect\n    ];\n});\n_c = Web3Provider;\nfunction useWeb3() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(Web3Context);\n    if (context === undefined) {\n        throw new Error('useWeb3 must be used within a Web3Provider');\n    }\n    return context;\n}\n_s1(useWeb3, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"Web3Provider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0cy9XZWIzQ29udGV4dC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRWlGO0FBQ3BCO0FBQ2xCO0FBQ0Q7QUFDa0M7QUFFNUUsNEJBQTRCO0FBQzVCLE1BQU1ZLGtCQUFrQjtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQUVELDZDQUE2QztBQUM3QyxNQUFNQyxtQkFBbUI7QUFlekIsTUFBTUMsNEJBQWNkLG9EQUFhQSxDQUE4QmU7QUFFL0QsZ0RBQWdEO0FBQ2hELE1BQU1DLHVCQUF1QjtBQUV0QixTQUFTQyxhQUFhLEtBQXFDO1FBQXJDLEVBQUVDLFFBQVEsRUFBMkIsR0FBckM7O0lBQzNCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxXQUFXLEVBQUUsR0FBR2hCLGlEQUFVQTtJQUMzQyxNQUFNLEVBQUVpQixZQUFZLEVBQUUsR0FBR2hCLGlEQUFVQTtJQUNuQyxNQUFNLEVBQUVpQixZQUFZQyxlQUFlLEVBQUUsR0FBR2pCLG9EQUFhQTtJQUNyRCxNQUFNLENBQUNrQixVQUFVQyxZQUFZLEdBQUd2QiwrQ0FBUUEsQ0FBa0I7SUFDMUQsTUFBTSxDQUFDd0IsT0FBT0MsU0FBUyxHQUFHekIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQzBCLHFCQUFxQkMsdUJBQXVCLEdBQUczQiwrQ0FBUUEsQ0FBQztJQUUvRCxxQ0FBcUM7SUFDckNDLGdEQUFTQTtrQ0FBQztZQUNSLE1BQU0yQjtnRUFBd0I7b0JBQzVCLElBQUksSUFBNkIsRUFBRTt3QkFDakMsTUFBTUMsa0JBQWtCQyxhQUFhQyxPQUFPLENBQUNqQiwwQkFBMEI7d0JBRXZFLElBQUllLG1CQUFtQixDQUFDWCxhQUFhOzRCQUNuQyxJQUFJO2dDQUNGLHlEQUF5RDtnQ0FDekQsTUFBTUMsYUFBYTtvQ0FBRWEsV0FBVzNCLDBEQUFRQTtnQ0FBRzs0QkFDN0MsRUFBRSxPQUFPNEIsS0FBSztnQ0FDWkMsUUFBUVYs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WUFDZFUsUUFBUVYsS0FBSyxDQUFDLCtCQUErQkE7WUFDN0MsTUFBTUE7UUFDUjtJQUNGO0lBRUEscUJBQ0UsOERBQUNaLFlBQVlvRyxRQUFRO1FBQUNsQyxPQUFPO1lBQzNCNUQ7WUFDQStGLFNBQVNoRztZQUNUNkI7WUFDQTFCO1lBQ0EyQjtZQUNBNkQ7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQXpGO1FBQ0Y7O1lBQ0dFLHVCQUFTLDhEQUFDMEY7Z0JBQUlDLE9BQU87b0JBQUNDLE9BQU07b0JBQU1DLGNBQWE7Z0JBQUM7O29CQUFHO29CQUFlN0Y7Ozs7Ozs7WUFDbEVSOzs7Ozs7O0FBR1A7R0E5UmdCRDs7UUFDbUJiLDZDQUFVQTtRQUNsQkMsNkNBQVVBO1FBQ0tDLGdEQUFhQTs7O0tBSHZDVztBQWdTVCxTQUFTdUc7O0lBQ2QsTUFBTUMsVUFBVXhILGlEQUFVQSxDQUFDYTtJQUMzQixJQUFJMkcsWUFBWTFHLFdBQVc7UUFDekIsTUFBTSxJQUFJdUMsTUFBTTtJQUNsQjtJQUNBLE9BQU9tRTtBQUNUO0lBTmdCRCIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvc3NkL3Byb2plY3Qvc3JjL2NvbnRleHRzL1dlYjNDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgUmVhY3ROb2RlLCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VBY2NvdW50LCB1c2VDb25uZWN0LCB1c2VEaXNjb25uZWN0IH0gZnJvbSAnd2FnbWknXG5pbXBvcnQgeyBpbmplY3RlZCB9IGZyb20gJ3dhZ21pL2Nvbm5lY3RvcnMnXG5pbXBvcnQgeyBDb250cmFjdCwgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IHNhdmVSZW50YWxzLCBsb2FkUmVudGFscywgUmVudGFsIH0gZnJvbSAnQC9zZXJ2aWNlcy9yZW50YWxTdG9yYWdlJztcblxuLy8gSW1wb3J0IEFCSSB3aGVuIGF2YWlsYWJsZVxuY29uc3QgRklMTV9SRU5UQUxfQUJJID0gW1xuICBcImZ1bmN0aW9uIGFkZEZpbG0oc3RyaW5nIG1lbW9yeSBfaWQsIHVpbnQyNTYgX3JlbnRhbFByaWNlKSBwdWJsaWNcIixcbiAgXCJmdW5jdGlvbiByZW50RmlsbShzdHJpbmcgbWVtb3J5IF9maWxtSWQpIHB1YmxpYyBwYXlhYmxlXCIsXG4gIFwiZnVuY3Rpb24gZW5kUmVudGFsKHN0cmluZyBtZW1vcnkgX2ZpbG1JZCkgcHVibGljXCIsXG4gIFwiZnVuY3Rpb24gZ2V0UmVudGFsUHJpY2Uoc3RyaW5nIG1lbW9yeSBfZmlsbUlkKSBwdWJsaWMgdmlldyByZXR1cm5zICh1aW50MjU2KVwiLFxuICBcImZ1bmN0aW9uIGlzRmlsbUF2YWlsYWJsZShzdHJpbmcgbWVtb3J5IF9maWxtSWQpIHB1YmxpYyB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0VXNlclJlbnRhbHMoYWRkcmVzcyBfdXNlcikgcHVibGljIHZpZXcgcmV0dXJucyAodHVwbGUoc3RyaW5nIGZpbG1JZCwgYWRkcmVzcyByZW50ZXIsIHVpbnQyNTYgc3RhcnRUaW1lLCB1aW50MjU2IGVuZFRpbWUsIGJvb2wgaXNBY3RpdmUpW10gbWVtb3J5KVwiXG5dO1xuXG4vLyBVcGRhdGVkIHdpdGggdGhlIGRlcGxveWVkIGNvbnRyYWN0IGFkZHJlc3NcbmNvbnN0IENPTlRSQUNUX0FERFJFU1MgPSBcIjB4OEQxNTE3MzYwODg2ZTg1ZDhlOTRFM0U2NDc0MkE3NjM3Mjc3YzVmMlwiO1xuXG5pbnRlcmZhY2UgV2ViM0NvbnRleHRUeXBlIHtcbiAgaXNDb25uZWN0ZWQ6IGJvb2xlYW5cbiAgYWNjb3VudDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGNvbm5lY3Q6ICgpID0+IFByb21pc2U8dm9pZD5cbiAgZGlzY29ubmVjdDogKCkgPT4gdm9pZFxuICByZW50RmlsbTogKGZpbG1JZDogc3RyaW5nLCBwcmljZTogc3RyaW5nLCBmaWxtVGl0bGU/OiBzdHJpbmcsIGZpbG1Qb3N0ZXI/OiBzdHJpbmcpID0+IFByb21pc2U8YW55PlxuICBlbmRSZW50YWw6IChmaWxtSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPlxuICBnZXRGaWxtUHJpY2U6IChmaWxtSWQ6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmc+XG4gIGlzRmlsbUF2YWlsYWJsZTogKGZpbG1JZDogc3RyaW5nKSA9PiBQcm9taXNlPGJvb2xlYW4+XG4gIGdldFVzZXJSZW50YWxzOiAoKSA9PiBQcm9taXNlPGFueVtdPlxuICBjb250cmFjdDogQ29udHJhY3QgfCBudWxsXG59XG5cbmNvbnN0IFdlYjNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxXZWIzQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZClcblxuLy8gTG9jYWwgc3RvcmFnZSBrZXkgZm9yIHdhbGxldCBjb25uZWN0aW9uIHN0YXRlXG5jb25zdCBXQUxMRVRfQ09OTkVDVEVEX0tFWSA9ICd3YWxsZXRfY29ubmVjdGVkJztcblxuZXhwb3J0IGZ1bmN0aW9uIFdlYjNQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IHsgYWRkcmVzcywgaXNDb25uZWN0ZWQgfSA9IHVzZUFjY291bnQoKTtcbiAgY29uc3QgeyBjb25uZWN0QXN5bmMgfSA9IHVzZUNvbm5lY3QoKTtcbiAgY29uc3QgeyBkaXNjb25uZWN0OiB3YWdtaURpc2Nvbm5lY3QgfSA9IHVzZURpc2Nvbm5lY3QoKTtcbiAgY29uc3QgW2NvbnRyYWN0LCBzZXRDb250cmFjdF0gPSB1c2VTdGF0ZTxDb250cmFjdCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaW5pdGlhbExvYWRDb21wbGV0ZSwgc2V0SW5pdGlhbExvYWRDb21wbGV0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gQ2hlY2sgbG9jYWxTdG9yYWdlIG9uIGluaXRpYWwgbG9hZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNoZWNrU3RvcmVkQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBzdG9yZWRDb25uZWN0ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShXQUxMRVRfQ09OTkVDVEVEX0tFWSkgPT09ICd0cnVlJztcbiAgICAgICAgXG4gICAgICAgIGlmIChzdG9yZWRDb25uZWN0ZWQgJiYgIWlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byByZWNvbm5lY3Qgd2FsbGV0IGlmIGl0IHdhcyBwcmV2aW91c2x5IGNvbm5lY3RlZFxuICAgICAgICAgICAgYXdhaXQgY29ubmVjdEFzeW5jKHsgY29ubmVjdG9yOiBpbmplY3RlZCgpIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlc3RvcmUgd2FsbGV0IGNvbm5lY3Rpb246JywgZXJyKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFdBTExFVF9DT05ORUNURURfS0VZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldEluaXRpYWxMb2FkQ29tcGxldGUodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBjaGVja1N0b3JlZENvbm5lY3Rpb24oKTtcbiAgfSwgW10pO1xuXG4gIC8vIFVwZGF0ZSBjb250cmFjdCB3aGVuIGNvbm5lY3Rpb24gY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc0Nvbm5lY3RlZCAmJiBhZGRyZXNzKSB7XG4gICAgICAvLyBTYXZlIGNvbm5lY3Rpb24gc3RhdGUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5pdGlhbExvYWRDb21wbGV0ZSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShXQUxMRVRfQ09OTkVDVEVEX0tFWSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxpemVDb250cmFjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRDb250cmFjdChudWxsKTtcbiAgICAgIC8vIENsZWFyIGNvbm5lY3Rpb24gc3RhdGUgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBpbml0aWFsTG9hZENvbXBsZXRlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFdBTExFVF9DT05ORUNURURfS0VZKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpc0Nvbm5lY3RlZCwgYWRkcmVzcywgaW5pdGlhbExvYWRDb21wbGV0ZV0pO1xuXG4gIGNvbnN0IGluaXRpYWxpemVDb250cmFjdCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuZXRoZXJldW0gfHwgIWFkZHJlc3MpIHJldHVybjtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgICAgY29uc3QgY29udHJhY3RJbnN0YW5jZSA9IG5ldyBDb250cmFjdChDT05UUkFDVF9BRERSRVNTLCBGSUxNX1JFTlRBTF9BQkksIHNpZ25lcik7XG4gICAgICBzZXRDb250cmFjdChjb250cmFjdEluc3RhbmNlKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIGNvbnRyYWN0OiAnICsgKGVycj8ubWVzc2FnZSB8fCBlcnIpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY29ubmVjdCA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY29ubmVjdEFzeW5jKHsgY29ubmVjdG9yOiBpbmplY3RlZCgpIH0pO1xuICAgICAgLy8gQ29ubmVjdGlvbiBzdGF0ZSBpcyBzYXZlZCBpbiB0aGUgdXNlRWZmZWN0IHRoYXQgd2F0Y2hlcyBpc0Nvbm5lY3RlZFxuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBzZXRFcnJvcignV2FsbGV0IGNvbm5lY3Rpb24gZmFpbGVkOiAnICsgKGVycj8ubWVzc2FnZSB8fCBlcnIpKTtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBkaXNjb25uZWN0ID0gKCkgPT4ge1xuICAgIHdhZ21pRGlzY29ubmVjdCgpO1xuICAgIC8vIENvbm5lY3Rpb24gc3RhdGUgaXMgY2xlYXJlZCBpbiB0aGUgdXNlRWZmZWN0IHRoYXQgd2F0Y2hlcyBpc0Nvbm5lY3RlZFxuICB9O1xuXG4gIGNvbnN0IHJlbnRGaWxtID0gYXN5bmMgKGZpbG1JZDogc3RyaW5nLCBwcmljZTogc3RyaW5nLCBmaWxtVGl0bGU/OiBzdHJpbmcsIGZpbG1Qb3N0ZXI/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkgdGhyb3cgbmV3IEVycm9yKCdObyBjcnlwdG8gd2FsbGV0IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzay4nKTtcbiAgICBpZiAoIWlzQ29ubmVjdGVkIHx8ICFhZGRyZXNzKSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJyk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENoZWNrIGlmIGZpbG0gaXMgYWxyZWFkeSByZW50ZWQgYnkgdGhpcyB1c2VyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3Qgc3RvcmVkUmVudGFsc0tleSA9IGByZW50YWxzXyR7YWRkcmVzcy50b0xvd2VyQ2FzZSgpfWA7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJlbnRhbHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yZWRSZW50YWxzS2V5KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdG9yZWRSZW50YWxzKSB7XG4gICAgICAgICAgY29uc3QgdXNlclJlbnRhbHMgPSBKU09OLnBhcnNlKHN0b3JlZFJlbnRhbHMpO1xuICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBmaWxtIGlzIGFscmVhZHkgaW4gYWN0aXZlIHJlbnRhbHNcbiAgICAgICAgICBjb25zdCBpc0FscmVhZHlSZW50ZWQgPSB1c2VyUmVudGFscy5zb21lKChyZW50YWw6IGFueSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlbnRhbC5maWxtSWQgPT09IGZpbG1JZCAmJiBuZXcgRGF0ZShyZW50YWwuZXhwaXJlc0F0KSA+IG5vdztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaXNBbHJlYWR5UmVudGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIGFscmVhZHkgcmVudGVkIHRoaXMgZmlsbS4gQ2hlY2sgeW91ciByZW50YWxzIHBhZ2UgdG8gd2F0Y2ggaXQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Ccm93c2VyUHJvdmlkZXIod2luZG93LmV0aGVyZXVtKTtcbiAgICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgICAgY29uc3QgdXNlckFkZHJlc3MgPSBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgLy9FVEggYWRkcmVzcyB0aGF0IHJlY2VpdmUgRVRIIGZyb20gdXNlcnNcbiAgICAgIGNvbnN0IGFkbWluQWRkcmVzcyA9ICcweGVDMWY3ODJkNjc1NzVGRTFFNjIwNzg5ODZiMDVhMDUzYmRENDY2MDInO1xuICAgICAgbGV0IGV0aEJhbGFuY2UgPSBhd2FpdCBwcm92aWRlci5nZXRCYWxhbmNlKHVzZXJBZGRyZXNzKTtcbiAgICAgIGNvbnN0IHByaWNlV2VpID0gZXRoZXJzLnBhcnNlRXRoZXIocHJpY2UpO1xuICAgICAgLy8gRGVidWc6IGxvZyB0eXBlcyBhbmQgdmFsdWVzXG4gICAgICBjb25zb2xlLmxvZygnREVCVUcgZXRoQmFsYW5jZTonLCBldGhCYWxhbmNlLCB0eXBlb2YgZXRoQmFsYW5jZSk7XG4gICAgICBjb25zb2xlLmxvZygnREVCVUcgcHJpY2VXZWk6JywgcHJpY2VXZWksIHR5cGVvZiBwcmljZVdlaSk7XG4gICAgICAvLyBFbnN1cmUgYm90aCBhcmUgQmlnSW50IGZvciBjb21wYXJpc29uXG4gICAgICBpZiAodHlwZW9mIGV0aEJhbGFuY2UgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGV0aEJhbGFuY2UgPSBCaWdJbnQoZXRoQmFsYW5jZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJpY2VXZWkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJpY2VXZWkgaXMgbm90IGEgYmlnaW50Jyk7XG4gICAgICB9XG4gICAgICBpZiAoZXRoQmFsYW5jZSA8IHByaWNlV2VpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IGJhbGFuY2UgdG8gcmVudCB0aGlzIGZpbG0uJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdSZW50aW5nIGZpbG06JywgeyBmaWxtSWQsIHByaWNlLCBmaWxtVGl0bGUgfSk7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgRVRIIHRvIGFkbWluXG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICB0bzogYWRtaW5BZGRyZXNzLFxuICAgICAgICB2YWx1ZTogcHJpY2VXZWlcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSByZW50YWwgaW5mb3JtYXRpb24gaW4gbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgc2V2ZW5EYXlzSW5NcyA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbm93ICsgc2V2ZW5EYXlzSW5NcztcbiAgICAgIFxuICAgICAgY29uc3QgbmV3UmVudGFsID0ge1xuICAgICAgICBpZDogYCR7ZmlsbUlkfS0ke25vd31gLFxuICAgICAgICBmaWxtSWQ6IGZpbG1JZCxcbiAgICAgICAgdGl0bGU6IGZpbG1UaXRsZSB8fCBgRmlsbSAke2ZpbG1JZH1gLFxuICAgICAgICBwb3N0ZXI6IGZpbG1Qb3N0ZXIgfHwgJ2h0dHBzOi8vdmlhLnBsYWNlaG9sZGVyLmNvbS8zMDB4NDUwP3RleHQ9RmlsbScsXG4gICAgICAgIHJlbnRlZEF0OiBuZXcgRGF0ZShub3cpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGV4cGlyZXNBdDogbmV3IERhdGUoZXhwaXJlc0F0KS50b0lTT1N0cmluZygpLFxuICAgICAgICBzdGF0dXM6ICdhY3RpdmUnIGFzIGNvbnN0LFxuICAgICAgICBwcmljZTogcHJpY2VcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEdldCBleGlzdGluZyByZW50YWxzIGFuZCBhZGQgdGhlIG5ldyBvbmVcbiAgICAgIGxldCB1c2VyUmVudGFscyA9IGF3YWl0IGxvYWRSZW50YWxzKHVzZXJBZGRyZXNzKTtcbiAgICAgIHVzZXJSZW50YWxzLnB1c2gobmV3UmVudGFsKTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0byBib3RoIGxvY2FsU3RvcmFnZSBhbmQgc2VydmVyIGZpbGUgc3RvcmFnZVxuICAgICAgYXdhaXQgc2F2ZVJlbnRhbHModXNlckFkZHJlc3MsIHVzZXJSZW50YWxzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdSZW50YWwgc2F2ZWQgdG8gc3RvcmFnZTonLCBuZXdSZW50YWwpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZmlsbSByZW50YWwgY291bnQgYW5kIHJldmVudWUgaW4gZmlsbXMuanNvblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmV0Y2ggY3VycmVudCBmaWxtcyBkYXRhXG4gICAgICAgIGNvbnN0IGZpbG1zUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9maWxtcycpO1xuICAgICAgICBpZiAoZmlsbXNSZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGZpbG1zID0gYXdhaXQgZmlsbXNSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlsbSB0aGF0IHdhcyByZW50ZWRcbiAgICAgICAgICBjb25zdCBmaWxtSW5kZXggPSBmaWxtcy5maW5kSW5kZXgoKGZpbG06IGFueSkgPT4gZmlsbS5pZCA9PT0gZmlsbUlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZmlsbUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gSW5jcmVtZW50IHJlbnRhbCBjb3VudFxuICAgICAgICAgICAgZmlsbXNbZmlsbUluZGV4XS5yZW50YWxzID0gKGZpbG1zW2ZpbG1JbmRleF0ucmVudGFscyB8fCAwKSArIDE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFkZCByZXZlbnVlIChjb252ZXJ0IHByaWNlIHN0cmluZyB0byBudW1iZXIpXG4gICAgICAgICAgICBmaWxtc1tmaWxtSW5kZXhdLnJldmVudWUgPSAoZmlsbXNbZmlsbUluZGV4XS5yZXZlbnVlIHx8IDApICsgcGFyc2VGbG9hdChwcmljZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIGZpbG0gJHtmaWxtSWR9IHJlbnRhbHMgdG8gJHtmaWxtc1tmaWxtSW5kZXhdLnJlbnRhbHN9IGFuZCByZXZlbnVlIHRvICR7ZmlsbXNbZmlsbUluZGV4XS5yZXZlbnVlfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTYXZlIHVwZGF0ZWQgZmlsbXMgZGF0YSBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIGF3YWl0IGZldGNoKCcvYXBpL2ZpbG1zJywge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZpbG1zKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaWxtcyBkYXRhIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh1cGRhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBmaWxtIHJlbnRhbCBzdGF0aXN0aWNzOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgLy8gQ29udGludWUgZXhlY3V0aW9uIGV2ZW4gaWYgc3RhdGlzdGljcyB1cGRhdGUgZmFpbHNcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHR4O1xuICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVudCBmaWxtOicsIGVycik7XG4gICAgICAvLyBIYW5kbGUgTWV0YU1hc2sgdXNlciByZWplY3Rpb25cbiAgICAgIGlmIChcbiAgICAgICAgKGVycj8uY29kZSA9PT0gNDAwMSkgfHxcbiAgICAgICAgKGVycj8ucmVhc29uID09PSAncmVqZWN0ZWQnKSB8fFxuICAgICAgICAoZXJyPy5tZXNzYWdlPy5pbmNsdWRlcygnVXNlciBkZW5pZWQgdHJhbnNhY3Rpb24gc2lnbmF0dXJlJykpIHx8XG4gICAgICAgIChlcnI/LmNvZGUgPT09ICdBQ1RJT05fUkVKRUNURUQnKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gY2FuY2VsbGVkIGJ5IHVzZXIuJyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyPy5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gcmVudCBmaWxtLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVuZFJlbnRhbCA9IGFzeW5jIChmaWxtSWQ6IHN0cmluZykgPT4ge1xuICAgIC8vIFdlYjMgZnVuY3Rpb25hbGl0eSB0ZW1wb3JhcmlseSBkaXNhYmxlZCB3aGlsZSB3ZSBmb2N1cyBvbiB0cmFkaXRpb25hbCBhdXRoXG4gICAgY29uc29sZS5sb2coJ1dlYjMgZnVuY3Rpb25hbGl0eSB0ZW1wb3JhcmlseSBkaXNhYmxlZCcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdXZWIzIGZ1bmN0aW9uYWxpdHkgdGVtcG9yYXJpbHkgZGlzYWJsZWQnKVxuICAgIC8qXG4gICAgaWYgKCFjb250cmFjdCkgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQnKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmVuZFJlbnRhbChmaWxtSWQpXG4gICAgICBhd2FpdCB0eC53YWl0KClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGVuZCByZW50YWw6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICAqL1xuICB9XG5cbiAgY29uc3QgZ2V0RmlsbVByaWNlID0gYXN5bmMgKGZpbG1JZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICAvLyBXZWIzIGZ1bmN0aW9uYWxpdHkgdGVtcG9yYXJpbHkgZGlzYWJsZWQgd2hpbGUgd2UgZm9jdXMgb24gdHJhZGl0aW9uYWwgYXV0aFxuICAgIGNvbnNvbGUubG9nKCdXZWIzIGZ1bmN0aW9uYWxpdHkgdGVtcG9yYXJpbHkgZGlzYWJsZWQnKVxuICAgIHJldHVybiAnMC4wMScgLy8gUmV0dXJuIGEgZGVmYXVsdCBwcmljZVxuICAgIC8qXG4gICAgaWYgKCFjb250cmFjdCkgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBub3QgaW5pdGlhbGl6ZWQnKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcmljZSA9IGF3YWl0IGNvbnRyYWN0LmdldFJlbnRhbFByaWNlKGZpbG1JZClcbiAgICAgIGNvbnN0IGV0aFByaWNlID0gZXRoZXJzLmZvcm1hdEV0aGVyKHByaWNlLnRvU3RyaW5nKCkpXG4gICAgICByZXR1cm4gZXRoUHJpY2VcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBmaWxtIHByaWNlOicsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgKi9cbiAgfVxuXG4gIGNvbnN0IGlzRmlsbUF2YWlsYWJsZSA9IGFzeW5jIChmaWxtSWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIC8vIFdlYjMgZnVuY3Rpb25hbGl0eSB0ZW1wb3JhcmlseSBkaXNhYmxlZCB3aGlsZSB3ZSBmb2N1cyBvbiB0cmFkaXRpb25hbCBhdXRoXG4gICAgY29uc29sZS5sb2coJ1dlYjMgZnVuY3Rpb25hbGl0eSB0ZW1wb3JhcmlseSBkaXNhYmxlZCcpXG4gICAgcmV0dXJuIHRydWUgLy8gRGVmYXVsdCB0byBhdmFpbGFibGVcbiAgICAvKlxuICAgIGlmICghY29udHJhY3QpIHRocm93IG5ldyBFcnJvcignQ29udHJhY3Qgbm90IGluaXRpYWxpemVkJylcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGNvbnRyYWN0LmlzRmlsbUF2YWlsYWJsZShmaWxtSWQpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjaGVjayBmaWxtIGF2YWlsYWJpbGl0eTonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICAgICovXG4gIH1cblxuICBjb25zdCBnZXRVc2VyUmVudGFscyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkgdGhyb3cgbmV3IEVycm9yKCdObyBjcnlwdG8gd2FsbGV0IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzay4nKTtcbiAgICBpZiAoIWlzQ29ubmVjdGVkIHx8ICFhZGRyZXNzKSB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgY29ubmVjdGVkJyk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyByZW50YWxzIGZvciBhZGRyZXNzOicsIGFkZHJlc3MpO1xuICAgICAgXG4gICAgICAvLyBMb2FkIHJlbnRhbHMgZnJvbSBib3RoIGxvY2FsU3RvcmFnZSBhbmQgc2VydmVyIGZpbGUgc3RvcmFnZVxuICAgICAgY29uc3QgdXNlclJlbnRhbHMgPSBhd2FpdCBsb2FkUmVudGFscyhhZGRyZXNzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1JldHJpZXZlZCByZW50YWxzIGZyb20gc3RvcmFnZTonLCB1c2VyUmVudGFscyk7XG4gICAgICByZXR1cm4gdXNlclJlbnRhbHM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgdXNlciByZW50YWxzOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPFdlYjNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBpc0Nvbm5lY3RlZCxcbiAgICAgIGFjY291bnQ6IGFkZHJlc3MsXG4gICAgICBjb25uZWN0LFxuICAgICAgZGlzY29ubmVjdCxcbiAgICAgIHJlbnRGaWxtLFxuICAgICAgZW5kUmVudGFsLFxuICAgICAgZ2V0RmlsbVByaWNlLFxuICAgICAgaXNGaWxtQXZhaWxhYmxlLFxuICAgICAgZ2V0VXNlclJlbnRhbHMsXG4gICAgICBjb250cmFjdFxuICAgIH19PlxuICAgICAge2Vycm9yICYmIDxkaXYgc3R5bGU9e3tjb2xvcjoncmVkJyxtYXJnaW5Cb3R0b206OH19PldhbGxldCBFcnJvcjoge2Vycm9yfTwvZGl2Pn1cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1dlYjNDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlV2ViMygpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoV2ViM0NvbnRleHQpXG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVdlYjMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFdlYjNQcm92aWRlcicpXG4gIH1cbiAgcmV0dXJuIGNvbnRleHRcbn0iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUFjY291bnQiLCJ1c2VDb25uZWN0IiwidXNlRGlzY29ubmVjdCIsImluamVjdGVkIiwiQ29udHJhY3QiLCJldGhlcnMiLCJzYXZlUmVudGFscyIsImxvYWRSZW50YWxzIiwiRklMTV9SRU5UQUxfQUJJIiwiQ09OVFJBQ1RfQUREUkVTUyIsIldlYjNDb250ZXh0IiwidW5kZWZpbmVkIiwiV0FMTEVUX0NPTk5FQ1RFRF9LRVkiLCJXZWIzUHJvdmlkZXIiLCJjaGlsZHJlbiIsImFkZHJlc3MiLCJpc0Nvbm5lY3RlZCIsImNvbm5lY3RBc3luYyIsImRpc2Nvbm5lY3QiLCJ3YWdtaURpc2Nvbm5lY3QiLCJjb250cmFjdCIsInNldENvbnRyYWN0IiwiZXJyb3IiLCJzZXRFcnJvciIsImluaXRpYWxMb2FkQ29tcGxldGUiLCJzZXRJbml0aWFsTG9hZENvbXBsZXRlIiwiY2hlY2tTdG9yZWRDb25uZWN0aW9uIiwic3RvcmVkQ29ubmVjdGVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvbm5lY3RvciIsImVyciIsImNvbnNvbGUiLCJyZW1vdmVJdGVtIiwic2V0SXRlbSIsImluaXRpYWxpemVDb250cmFjdCIsIndpbmRvdyIsImV0aGVyZXVtIiwicHJvdmlkZXIiLCJCcm93c2VyUHJvdmlkZXIiLCJzaWduZXIiLCJnZXRTaWduZXIiLCJjb250cmFjdEluc3RhbmNlIiwibWVzc2FnZSIsImNvbm5lY3QiLCJyZW50RmlsbSIsImZpbG1JZCIsInByaWNlIiwiZmlsbVRpdGxlIiwiZmlsbVBvc3RlciIsIkVycm9yIiwic3RvcmVkUmVudGFsc0tleSIsInRvTG93ZXJDYXNlIiwic3RvcmVkUmVudGFscyIsInVzZXJSZW50YWxzIiwiSlNPTiIsInBhcnNlIiwibm93IiwiRGF0ZSIsImlzQWxyZWFkeVJlbnRlZCIsInNvbWUiLCJyZW50YWwiLCJleHBpcmVzQXQiLCJ1c2VyQWRkcmVzcyIsImdldEFkZHJlc3MiLCJhZG1pbkFkZHJlc3MiLCJldGhCYWxhbmNlIiwiZ2V0QmFsYW5jZSIsInByaWNlV2VpIiwicGFyc2VFdGhlciIsImxvZyIsIkJpZ0ludCIsInRvU3RyaW5nIiwidHgiLCJzZW5kVHJhbnNhY3Rpb24iLCJ0byIsInZhbHVlIiwid2FpdCIsInNldmVuRGF5c0luTXMiLCJuZXdSZW50YWwiLCJpZCIsInRpdGxlIiwicG9zdGVyIiwicmVudGVkQXQiLCJ0b0lTT1N0cmluZyIsInN0YXR1cyIsInB1c2giLCJmaWxtc1Jlc3BvbnNlIiwiZmV0Y2giLCJvayIsImZpbG1zIiwianNvbiIsImZpbG1JbmRleCIsImZpbmRJbmRleCIsImZpbG0iLCJyZW50YWxzIiwicmV2ZW51ZSIsInBhcnNlRmxvYXQiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInN0cmluZ2lmeSIsInVwZGF0ZUVycm9yIiwiY29kZSIsInJlYXNvbiIsImluY2x1ZGVzIiwiZW5kUmVudGFsIiwiZ2V0RmlsbVByaWNlIiwiaXNGaWxtQXZhaWxhYmxlIiwiZ2V0VXNlclJlbnRhbHMiLCJQcm92aWRlciIsImFjY291bnQiLCJkaXYiLCJzdHlsZSIsImNvbG9yIiwibWFyZ2luQm90dG9tIiwidXNlV2ViMyIsImNvbnRleHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/contexts/Web3Context.tsx\n"));

/***/ })

});